February 1

Is there one stack per thread or one stack per process?
    Stack used for keeping track of execution, one stack per thread to 
    keep track of execution

What is the biggest advantage of implementing threads in the user space?
    Allows for each thread to handle it's own thread table. No interaction
    with kernel is necessary. Efficiency.

    Scheduling per process.

What is the biggest disadvantage?
    Could block system calls or decrease response time if shittily developed

-----------
February 3

Three ways for interprocess communication
    1. passing messages through the kernel
    2. sharing a region of physical memory
    3. through asynchronous signals or alerts

----------
February 8

Busy waiting is inefficient, but it is effective at eliminating race conditions
It is possible to have race conditions even sequentially if there is no mutual exclusion mechanism

Mutual Exclusion
    - Why are solutions discussed not good enough?
    -- They require busy waiting, wasting CPU time
    -- Low priority jobs block high priority ones

    - How to improve?
    -- Let processes sleep rather than busy waiting
    
    -- System call Sleep
    --- Caller gives up the CPU for some duration of time until other processes wake it up
    
    -- System call Wakeup
    --- Caller wakes up some sleeping process


    Semaphores
-- Purpose: count the number of wakeups saved
-- Solves the lost wakeup problem
-- How?
    - Define a count variable, or a semaphore
    - Semaphore is initialized to zero, no wakeup is saved
    - Operations:
        Down (for sleep)
        Up (for wakeup)

    Down and up are atomic, done with help of hardware
    
    Requirement 1 for fix of producer/consumer
    - Semaphore mutex initialized to 1, only 1 process in critical section at a time
    Requirement 2 
    - semaphore full initialized to 0
    - semaphore empty initialized to n to block consumer when buffer is empty


    semaphore mutex = 1; //binary semaphore
    semaphore empty = n; // counts empty slots
    semaphore full = 0 // counts occupied spots

    producer: down(empty), down(mutex), up(mutex), up(full)
    consumer: down(full), down(mutex), up(mutex), up(empty)

    If we were to switch the down order, it can cause deadlocks
    If we were to switch the up order, it can reduce performance

Reader/Writer Problem
    It's possible that the readers if supplied continuously will indefinitely block the writers
    Separate queue that when a writer tries to do down, it stops all the readers until the write is complete
    


